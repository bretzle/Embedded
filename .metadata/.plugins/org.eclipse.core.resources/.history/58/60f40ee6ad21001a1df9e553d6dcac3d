#include "timing.h"

#define GPIOA_BASE (int *) 0x40020000
#define GPIOB_BASE (int *) 0x40020400
#define GPIOC_BASE (int *) 0x40020800

#define MODER 0
#define IDR 4
#define ODR 5
#define BSRR 6
#define Px0 0
#define Px1 1
#define Px2 2
#define Px3 3

#define SET 1
#define OUTPUT 1
#define RS_SET 1 << 0
#define RS_CLR 1 << (0 + 16)
#define RW_CLR 1 << (1 + 16)
#define E_SET 1 << 2
#define E_CLR 1 << (2 + 16)

void enable_GPIO(char);

void lcd_init(void) {
	enable_GPIO('B');
	for (int bit = 0; bit < 3; bit++) {
		GPIOB_BASE[MODER] &= ~(0b11 << (bit * 2));
		GPIOB_BASE[MODER] |= OUTPUT << (bit * 2);
	}

	enable_GPIO('C');
	for (int bit = 8; bit < 12; bit++) {
		GPIOC_BASE[MODER] &= ~(0b11 << (bit * 2));
		GPIOC_BASE[MODER] |= OUTPUT << (bit * 2);
	}

//	lcd_set_up();
}

void enable_GPIO(char port) {
	volatile uint32_t* rcc_ahb1enr = (uint32_t*) 0x40023830;

	switch (port) {
	case 'A':
		*rcc_ahb1enr |= (1 << 0);
		break;
	case 'B':
		*rcc_ahb1enr |= (1 << 1);
		break;
	case 'C':
		*rcc_ahb1enr |= (1 << 2);
		break;
	case 'D':
		*rcc_ahb1enr |= (1 << 3);
		break;
	case 'E':
		*rcc_ahb1enr |= (1 << 4);
		break;
	case 'F':
		*rcc_ahb1enr |= (1 << 5);
		break;
	case 'G':
		*rcc_ahb1enr |= (1 << 6);
		break;
	case 'H':
		*rcc_ahb1enr |= (1 << 7);
		break;
	}
}













void lcd_clear(void) {

}

void lcd_home(void) {

}

void lcd_set_position(int row, int col) {

}

void lcd_print_string(char *string[]) {

}

void lcd_print_num(int number) {

}
